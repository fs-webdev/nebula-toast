<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../nebula-element-mixin/nebula-element-mixin.html">

<dom-module id="nebula-toast">
  <template>
    <style>
      @keyframes bottomEnter {
        from { opacity: 0; transform: translateY(+100%); }
        to { opacity: 1; transform: translateY(0%); }
      }
      @keyframes bottomExit {
        from { opacity: 1; transform: translateY(0%); }
        to { opacity: 0; transform: translateY(+100%); }
      }
      @keyframes topEnter {
        from { opacity: 0; transform: translateY(-100%); }
        to { opacity: 1; transform: translateY(0%); }
      }
      @keyframes topExit {
        from { opacity: 1; transform: translateY(0%); }
        to { opacity: 0; transform: translateY(-100%); }
      }
      :host {
        position: fixed;
        display: none;
        left: 16px;
        right: 16px;
        max-width: 600px;
        margin: auto;
        padding: 16px;
        border: 0;
        border-radius: var(--nebula-ui-border-radius, 2px);
        overflow: hidden;
        cursor: pointer;
        user-select: none;
        background-color: var(--nebula-toast-background-color, dimgrey);
        color: var(--nebula-toast-color, white);
        z-index: 9999;
      }
      :host([position=bottom]) {
        bottom: 16px;
      }
      :host([position=top]) {
        top: 16px;
      }
      :host([animate]) {
        display: block;
      }
      :host([position=bottom][animate=enter]) {
        animation: bottomEnter 250ms;
      }
      :host([position=bottom][animate=exit]) {
        animation: bottomExit 250ms;
      }
      :host([position=top][animate=enter]) {
        animation: topEnter 250ms;
      }
      :host([position=top][animate=exit]) {
        animation: topExit 250ms;
      }
    </style>
    [[text]]
  </template>
  <script>
  (function() {
    'use strict'

    // symbols for private members
    const onAnimationEnd = Symbol()
    const onClick = Symbol()
    const onKeyDown = Symbol()
    const onOpenedChanged = Symbol()
    const opened = Symbol()
    const isAppended = Symbol()
    const timer = Symbol()

    // symbols for protected members
    const listen = Symbol.for('Nebula.ElementMixin.listen')
    const unlisten = Symbol.for('Nebula.ElementMixin.unlisten')
    const observe = Symbol.for('Nebula.ElementMixin.observe')
    const fire = Symbol.for('Nebula.ElementMixin.fire')

    /**
     * An animated toast notification.
    */
    class NebulaToast extends Nebula.ElementMixin(Polymer.Element) {

      /**
       * Gets the custom element name.
       * @type {string}
       */
      static get is() { return 'nebula-toast' }

      /**
       * Gets the property definitions for data binding.
       * @type {Object}
       * @property {boolean} opened - Indicates if the element is opened.
       * @property {string} position - Position of the toast (top or bottom).
       * @property {string} text - The text to display.
       * @property {string} duration - The duration (ms) before the element is automatically closed.
       */
      static get properties() {
        return {
          opened: {
            type: Boolean,
            reflectToAttribute: true,
            notify: true,
            value: false
          },
          position: {
            type: String,
            reflectToAttribute: true,
            value: 'bottom'
          },
          text: {
            type: String
          },
          duration: {
            type: Number,
            value: 5000
          }        
        }
      }

      /**
       * Lifecycle callback invoked when element has been initialized.
       */
      ready() {
        super.ready()
        this.setAttribute('role', 'alert')
        this[observe]('opened', this[onOpenedChanged])
        this[listen](this, 'click', this[onClick])
        this[listen](this, 'animationend', this[onAnimationEnd])
      }

      /**
      * Event handler triggered when a key is pressed down.
      * @private
      */ 
      [onKeyDown](e) {
        if (e.key === 'Escape') {
          e.preventDefault()
          this.set('opened', false)
        }
      }

      /**
      * Event handler triggered when the element opening or closing animation is complete.
      * @private
      */
      [onAnimationEnd](e) {
        if (this.opened) {
          this[fire]('opened')
        } else {
          this.removeAttribute('animate')
          this[fire]('closed')
        }
      }

      /**
       * Event handler triggered when the user taps the element.
       * @private
       */
      [onClick](e) {
        e.preventDefault()
        this.set('opened', false)
      }

      /**
       * Property observer triggered when the value of `opened` is changed.
       * @private
       */
      [onOpenedChanged](opened) {
        if (opened) {
          if (typeof this.duration === 'number' && this.duration > 0) {
            this[timer] = setTimeout(() => {
              this.set('opened', false)
            }, this.duration)
          }
          this[listen](document.body, 'keydown', this[onKeyDown])
          this.setAttribute('animate', 'enter')
        } else {
          this.setAttribute('animate', 'exit')
          clearTimeout(this[timer])
          this[unlisten](document.body, 'keydown')
        }
      }

      /**
      * Displays the element.
      * If the element does not have a parent, it will be auto appended to `document.body`.
      * A promise is returned that will resolve when the element has been closed.
      */
      show(props) {
        return new Promise((resolve, reject) => {
          try {
            // set properties if provided
            if (props) this.setProperties(props)

            // add element to document body if not parent
            if (!this.parentNode) {
              this[isAppended] = true
              document.body.appendChild(this)
            }
            
            // listen for our own closed event and resolve promise
            const handler = () => {
              this[unlisten](this, 'closed')
              if (this[isAppended]) {
                this[isAppended] = false
                document.body.removeChild(this)
              }
              resolve() 
            }

            this[listen](this, 'closed', handler)
            
            // open the element
            this.set('opened', true)
          } catch(error) {
            reject(error)
          }
        })
      }
    }

    customElements.define(NebulaToast.is, NebulaToast)
  }())
  </script>
</dom-module>
