<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../nebula-element-mixin/nebula-element-mixin.html">

<dom-module id="nebula-toast">
  <template>
    <style>
      :host {
        position: fixed;
        left: 0;
        right: 0;
        width: 85%;
        max-width: 600px;
        margin: 16px auto;
        padding: 16px;
        border: 0;
        border-radius: var(--nebula-ui-border-radius, 2px);
        overflow: hidden;
        cursor: pointer;
        user-select: none;
        background-color: dimgrey;
        color: white;
        z-index: 9999;
        visibility: hidden;
        opacity: 0;
        transition: transform 0.4s ease, opacity 0.4s linear, visibility 0s linear 0.4s;
      }
      :host([position=top]) {
        top: 0;
        transform: translateY(-100%); 
      }
      :host([position=bottom]) {
        bottom: 0;
        transform: translateY(+100%);
      }
      :host([opened]) {
        transform: translateY(0%);
        opacity: 1;
        visibility: visible;
        transition: transform 0.4s ease, opacity 0.4s linear;
      }
    </style>
    [[text]]
  </template>
  <script>
  (function() {
    'use strict'

    // symbols for private members
    const onTransitionEnd = Symbol()
    const onClick = Symbol()
    const onKeyDown = Symbol()
    const onOpenedChanged = Symbol()
    const opened = Symbol()
    const isAppended = Symbol()
    const timer = Symbol()

    // symbols for protected members
    const listen = Symbol.for('Nebula.ElementMixin.listen')
    const unlisten = Symbol.for('Nebula.ElementMixin.unlisten')
    const observe = Symbol.for('Nebula.ElementMixin.observe')
    const fire = Symbol.for('Nebula.ElementMixin.fire')

    /**
     * An animated toast notification.
    */
    class NebulaToast extends Nebula.ElementMixin(Polymer.Element) {

      /**
       * Gets the custom element name.
       * @type {string}
       */
      static get is() { return 'nebula-toast' }

      /**
       * Gets the property definitions for data binding.
       * @type {Object}
       * @property {boolean} opened - Indicates if the element is opened.
       * @property {string} position - Position of the toast (top or bottom).
       * @property {string} text - The text to display.
       * @property {string} duration - The duration (ms) before the element is automatically closed.
       */
      static get properties() {
        return {
          opened: {
            type: Boolean,
            reflectToAttribute: true,
            notify: true,
            value: false
          },
          position: {
            type: String,
            reflectToAttribute: true,
            value: 'bottom'
          },
          text: {
            type: String
          },
          duration: {
            type: Number,
            value: 5000
          }        
        }
      }

      /**
       * Lifecycle callback invoked when element has been initialized.
       */
      ready() {
        super.ready()
        this.setAttribute('role', 'alert')
        this[observe]('opened', this[onOpenedChanged])
        this[listen](this, 'click', this[onClick])
        this[listen](this, 'transitionend', this[onTransitionEnd])
      }

      /**
      * Event handler triggered when a key is pressed down.
      * @private
      */ 
      [onKeyDown](e) {
        if (e.key === 'Escape') {
          e.preventDefault()
          this.set('opened', false)
        }
      }

      /**
      * Event handler triggered when the element opening or closing animation is complete.
      * @private
      */
      [onTransitionEnd](e) {
        if (e.propertyName === 'opacity') {
          if (this.opened) {
            this[fire]('opened')
          } else {
            this[fire]('closed')
          }
        }
      }

      /**
       * Event handler triggered when the user taps the element.
       * @private
       */
      [onClick](e) {
        e.preventDefault()
        this.set('opened', false)
      }

      /**
       * Property observer triggered when the value of `opened` is changed.
       * @private
       */
      [onOpenedChanged](opened) {
        if (opened) {
          if (typeof this.duration === 'number' && this.duration > 0) {
            this[timer] = setTimeout(() => {
              this.set('opened', false)
            }, this.duration)
          }
          this[listen](document.body, 'keydown', this[onKeyDown])
        } else {
          clearTimeout(this[timer])
          this[unlisten](document.body, 'keydown')
        }
      }

      /**
      * Displays the element.
      * If the element does not have a parent, it will be auto appended to `document.body`.
      * A promise is returned that will resolve when the element has been closed.
      */
      show(props) {
        return new Promise((resolve, reject) => {
          try {
            // set properties if provided
            if (props) this.setProperties(props)

            // add element to document body if not parent
            if (!this.parentNode) {
              this[isAppended] = true
              document.body.appendChild(this)
            }
            
            // listen for our own closed event and resolve promise
            const handler = () => {
              this[unlisten](this, 'closed')
              if (this[isAppended]) {
                this[isAppended] = false
                document.body.removeChild(this)
              }
              resolve() 
            }
            this[listen](this, 'closed', handler)

            // open the toast in timeout closure to accomodate for animation
            // when appending new element
            setTimeout(() => {
              this.set('opened', true)
            })
          } catch(error) {
            reject(error)
          }
        })
      }
    }

    customElements.define(NebulaToast.is, NebulaToast)
  }())
  </script>
</dom-module>
